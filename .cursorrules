# Cursor Rules for Billiard Frontend Project

## Code Quality & Testing
- Always run `npm test` before any code changes
- Always run `npm run build` before commits to ensure TypeScript compliance
- Maintain 90%+ test coverage (`npm test -- --coverage`)
- Fix all ESLint errors (warnings are acceptable)
- Use shared test utilities from `src/__tests__/utils/testHelpers.tsx`

## Git & Deployment
- Run full test suite before any commit
- Commit messages in Japanese describing functional changes
- Always include: `ðŸ¤– Generated with [Claude Code](https://claude.ai/code)` and `Co-Authored-By: Claude <noreply@anthropic.com>`
- Only push when explicitly requested

## Architecture & Patterns
- Follow existing Material-UI and TypeScript patterns
- Maintain responsive design (xs, sm, md, lg breakpoints)
- Use Japanese as primary UI language
- Minimize use of `any` type
- Prefer editing existing files over creating new ones

## UI/UX Guidelines
- Keep UI/UX and interactions extremely simple
- NO hardcoded text strings - always use `useLanguage()` hook for i18n
- Implement as reusable common components when possible
- NO hardcoded colors - use `src/constants/colors.ts` color system
- Maintain unified design system and color format across app
- Propose file splitting when files exceed 500 lines, mandatory at 1000+ lines

## Game-Specific Rules
- SetMatch: Set history and player swapping functionality
- Rotation: Ball pocketing history and score calculation
- Bowlard: Frame management and score display
- ChessClock: Responsive design with correct interaction logic

## File Structure
- Components: `/src/components/` (UI components)
- Games: `/src/games/` (game engines)
- Tests: Follow existing `__tests__/` pattern
- Utils: Shared utilities in `/src/utils/`
- Types: All TypeScript definitions in `/src/types/`

## Testing Standards
- All new code must have corresponding tests
- Use factory functions from testHelpers.tsx
- Mock external dependencies properly
- Test both happy path and edge cases
- Maintain test file size under 1000 lines (split if larger)
- Create tests for all new common components

## Refactoring Rules
- BEFORE refactoring: Verify existing tests cover the target code
- NO tests = NO refactoring: Add tests first, then refactor
- AFTER refactoring: Always run `npm test` to verify no behavior changes
- Large refactors: Break into small, testable increments

## Debugging Commands
- Specific test: `npm test -- --run path/to/test.tsx`
- Coverage details: `npm test -- --coverage --reporter=verbose`
- Build verbose: `npm run build --verbose`

## Remember
- Mobile-first responsive design
- Existing code patterns over new implementations
- User experience and accessibility - keep it SIMPLE
- Gradual improvements over major refactors
- NO hardcoded strings or colors - use proper systems
- Common components over duplicated code
- File size discipline - split early and often